1.字符串匹配的KMP算法
    # http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html
    先算出部分匹配表，根据部分匹配表确定匹配串移动的距离。
2.AVL平衡二叉树
    # 查找快，修改与删除开销大，较少使用(基于内存）
3.R-B-tree
    # 查找快，修改与删除开销可接收，广泛用于C++的STL中，Map和Set都是用红黑树实现的
4.Ｂ-tree(平衡树)
    # 个人分析:Ｂ树相对于红黑树，每个节点需要的存储越多，每个节点可以存储更大的数据量。硬盘的存储远大与内存，相同数据量，Ｂ树要低于红黑树，这样ＩＯ查询少，速度快。
    # 考虑磁盘储存结构，B树的查找、删除、插入的代价都远远要小于任何二叉结构树(读写磁盘次数的降低)
    # 红黑树一个节点只能存出一个值，B树一个节点可以存储多个值，红黑树的深度会更大,定位时 红黑树的查找次数会大一些。
树结构排序，有前中后序遍历。排序相当于遍历一次，所以树结构排序很快。
５．一致性哈希(适用于分布式存储)
    hash存储
    假设有三台服务器(Ａ，Ｂ，Ｃ)用于存储数据，使用hash算法可能会跟A,B,C服务器有关,可能数据要分布存储。假设Ａ挂了,或者要新增一个
    节点Ｄ，之前根据hash存储的数据就不好搞了(数据可能要重新计算，因为算法应该是跟服务器数量有关)
    
    一致性哈希
    假设有三台服务器(Ａ，Ｂ，Ｃ)用于存储数据，使用一致性哈希算法跟服务器关系不是特别大。首先一致性哈希后得到的所有结果会构成一个环。
    先算出A,B,C服务器经过hash过在环上的位置，之后存储数据，每个数据经过hash得到环上的一个值,顺时针或逆时针找到最近的服务器(假设是Ａ）,将数据存储到服务器上。假设Ａ服务挂了，那只需要处理Ａ服务器上的数据，B,C是不需要处理的。相对之前处理多个服务器，到现在只
    补充:
        一致性哈希成环，通过hash计算后对2*32-1取余，最终能得到2*32-1个数值，将他们构成一个圆。
        服务器(A,B,C)在环上的位置可能很近，效果不好，可以利用虚拟化技术将服务器Ａ进行拆分成多个服务器Ａ'，多个服务器可以均匀分布，提高负载能力。
