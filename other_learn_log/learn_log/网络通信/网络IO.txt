1.同步IO之BlocKing IO
    假设python在读取一个文件时:
        1.程序通过调用系统提供的api，系统在准备数据，api未响应。程序等待。
        2.数据准备好了，api响应，系统将数据存到程序内存中，程序等待。
        3.数据全部到内存后，程序开始读取数据。
2.同步IO之NonBlocking IO
    假设python在读取一个文件时:
        1.程序通过调用系统提供的api，系统在准备数据，api响应错误。程序接收到响应非阻塞，可执行其他事情，晚点继续询问。
        2.数据准备好了，api响应正常，系统将数据存到程序内存中，程序等待。
        3.数据全部到内存后，程序开始读取数据。
3.同步IO之IO multiplexing(select、poll、epoll)
    假设python在读取一个文件时:
        1.程序通过调用系统select用于管理api。在数据准备与数据加载到内存中，程序都是在等待状态。
        2.IO多路复用, 其实select、poll、epoll的优势在于可以以较少的代价来同时监听处理多个IO。
4.异步IO
    假设python在读取一个文件时:
        1.程序通过调用系统api，api响应错误(数据未准备好)。程序溜了。
        2.系统准备数据，并加载数据到内存。最后通知程序(异步与同步在于系统是否具有通知用户端)。
        3.程序直接从内存读数据。
        4.网络IO,当加载数据时，程序会阻塞。
5.select、poll、epoll区别
    select 最早，大多数平台都支持。缺点:监听的文件描述符有限，随着文件描述符数量的增大，其复制的开销也线性增长。
        一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。
        原来多个连接是通过多个进程或线程实现。减少开销。
    poll   类似select，但无数量限制。
    epoll  性能最好的多路I/O就绪通知方法,支持水平触发和边缘触发。通过内存映射，减少复制开销。
总结:
    有一个问题是程序阻塞时应该是不占用cpu?考虑的方向是程序在获取不到数据的时候，如果不释放cpu或想要更快执行，那么他可以先去做点别的事情(假设请求，他可能是多任务的。(测试:requests访问url,20次，单进程单线程，需要2s左右。requests访问url,20次，单进程多个线程，需要0.5s左右。用户在阻塞的时候是不占用cpu的)
    假设一个用户去商城，他说要买衣服鞋子零食，如果衣服鞋子零食互不影响，可以看做是三个任务。
        用户先去买衣服，店家说要取货，用户可以说好了call我(如果商家可以通知用户，相当于异步)。
        然后直接去买鞋子，店家去隔壁拿货，用户等待，用户(请求,不占用店家(cpu)但程序不执行)阻塞。等待鞋子买好后在继续购物。
            假如用户需要购买的零食有十多种，这时候同鞋子一样，一个一个购买，用户阻塞。
            或者把零食单给店小二，他帮你去处理，你只需等待(被select阻塞，不占用cpu但程序不执行，休眠)，店小二(IO复用)只有某个零食到了就会通知你下单购买。


https://www.cnblogs.com/zhaof/p/8490045.html
https://aiohttp.readthedocs.io/en/stable/client_quickstart.html